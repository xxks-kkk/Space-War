<!--This Document is generated by GameMaker, if you edit it by hand then you do so at your own risk!-->
<object>
  <spriteName>&lt;undefined&gt;</spriteName>
  <solid>0</solid>
  <visible>-1</visible>
  <depth>0</depth>
  <persistent>0</persistent>
  <parentName>&lt;undefined&gt;</parentName>
  <maskName>&lt;undefined&gt;</maskName>
  <events>
    <event eventtype="0" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// setup a alarm (i.e alarm0) to go off in 15 steps
alarm[0] = 15

// setup revive timer
reviveTimer = 0;

// Game State Constants
PLAY = 0
GAME_OVER = 1
state = PLAY
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="2" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Allows the alarm event (i.e. alarm 0) happens repeatedly
// further reference: http://docs.yoyogames.com/source/dadiospice/000_using%20gamemaker/events/alarm%20event.html
alarm[0] = 15

// create the oEnemyFlyer object
//instance_create(view_xview[0] + view_wview[0],random(room_height), oEnemyFlyer)

/* check if the current position is valid to create the oEnemyFlyer object,
   by checking if there is a tile for the generating position, and if
   this can be shot by player (by checking there is any wall object around))  
   if so, create the oEnemyFlyer object
*/
xx = view_xview[0] + view_wview[0]
yy = random(room_height)

tile_id = tile_layer_find(1, xx, yy)
//show_debug_message("tile_id: " + string(tile_id))

if (tile_id == -1){
    if (instance_position(xx, yy+16,oWall) == noone &amp;&amp;
        instance_position(xx, yy-16, oWall) == noone &amp;&amp;
        instance_position(xx-16, yy, oWall) == noone )
        {
        instance_create(xx, yy, oEnemyFlyer1)
    }
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="3" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>/*
Now that we have our wide room and our view, let's make the view scroll.

- A view is not tied to any particular object, 
- so to tell it to scroll, we'll have to create some sort of controller object.  
- Create an object called oGame.  
- This object will not only handle the screen scrolling, 
  but it will keep track of some other variables, like score, drawing the HUD, etc.  
  In a more complex game, you may want to have multiple controller objects, 
  each charged with a specific task.  
  But since this is a relatively simple game, we'll put it all in a single oGame object.
*/

/*
Each view has x,y coordinates that define where the view is by the upper left corner of the view

view_xview[] is an array that stores all  the x coordinates of all the views
(view_yview[] for y). view_xview[0] stores the x coordinate of view 0.
*/

//view to move right 1 pixel with each step

if (state == PLAY){
    view_xview[0] += 1

    //we want the player to scroll, too.
    if (instance_exists(oPlayerShip)){ //ensure that the game does not crash if there is no oPlayerShip active in the room (we might if we destroy the player object when the player dies)
        oPlayerShip.x += 1
    }
    
    // Revive the player if he dies
    if (not instance_exists(oPlayerShip))
    {
        if (reviveTimer &gt; 0) reviveTimer -= 1;
        else instance_create(view_xview[0]+32, view_yview[0]+112, oPlayerShip);
    }

    /* Deactivating Objects Outside the View

    One more thing: every object that is active in the game 
    will slow the game down significantly, especially when doing collision checks.  
    To minimize this, you should try to deactivate any objects that are not needed.  
    This usually includes all the objects that are outside of the view.

    The other reason we might want to do this is to prevent the player from killing baddies 
    off screen by firing indiscriminately!

    This deactivates every object outside of the view and then activates every object inside the view, 
    with each step.  
    Make sure that the last two parameters of instance_deactivate_region() are false and true,
    respectively.  
    This specifies that you want to deactivate objects outside the region, 
    but don't want to deactivate the controller itself (that would be very bad!).

    If you have any other controller objects or otherwise important objects that you want 
    to leave on, make sure you activate them with instance_activate_object().
    */
    instance_deactivate_region(view_xview[0], 0, view_wview[0], room_height, false, true);
    instance_activate_region(view_xview[0], 0, view_wview[0], room_height, true);
 
}


if (state == GAME_OVER){
    if keyboard_check(vk_space){
        room_goto(rTitle)
    }
}

//A temporary way to quit the game (A menu come up with quit option would be nicer)
if mouse_check_button_pressed(mb_right){
    game_end()
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
    <event eventtype="8" enumb="0">
      <action>
        <libid>1</libid>
        <id>603</id>
        <kind>7</kind>
        <userelative>0</userelative>
        <isquestion>0</isquestion>
        <useapplyto>-1</useapplyto>
        <exetype>2</exetype>
        <functionname></functionname>
        <codestring></codestring>
        <whoName>self</whoName>
        <relative>0</relative>
        <isnot>0</isnot>
        <arguments>
          <argument>
            <kind>1</kind>
            <string>// Draw HUD

/*
draw_sprite() will draw a single frame of a sprite somewhere on the screen.  
You can also use draw_sprite_ext(), 
which has more parameters, such as the rotation and color of the image.
*/

if (state == PLAY){
    draw_sprite(sPlayerShipIcon, 0, view_xview[0]+3, 226)
    draw_text (view_xview[0]+14, 228, string(global.pLives))
}
else if (state == GAME_OVER){
    drawTextCentered("GAME OVER", view_xview[0], 112, 8, 320)
}
</string>
          </argument>
        </arguments>
      </action>
    </event>
  </events>
  <PhysicsObject>0</PhysicsObject>
  <PhysicsObjectSensor>0</PhysicsObjectSensor>
  <PhysicsObjectShape>0</PhysicsObjectShape>
  <PhysicsObjectDensity>0.5</PhysicsObjectDensity>
  <PhysicsObjectRestitution>0.100000001490116</PhysicsObjectRestitution>
  <PhysicsObjectGroup>0</PhysicsObjectGroup>
  <PhysicsObjectLinearDamping>0.100000001490116</PhysicsObjectLinearDamping>
  <PhysicsObjectAngularDamping>0.100000001490116</PhysicsObjectAngularDamping>
  <PhysicsObjectFriction>0.200000002980232</PhysicsObjectFriction>
  <PhysicsObjectAwake>-1</PhysicsObjectAwake>
  <PhysicsObjectKinematic>0</PhysicsObjectKinematic>
  <PhysicsShapePoints/>
</object>
